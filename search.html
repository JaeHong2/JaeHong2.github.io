<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>

    <!-- 웹폰트 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css"/>


    <!-- syntax.css 추가 -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="모르면 -> 알때까지 -> 공부해서 -> 해낸다." />
    <link rel="shortcut icon" href="https://JaeHong2.github.io//assets/built/images/favicon.jpg" type="image/png" />
    <link rel="canonical" href="https://JaeHong2.github.io//search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="오늘의 공부기록" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="모르면 -> 알때까지 -> 공부해서 -> 해낸다." />
    <meta property="og:url" content="https://JaeHong2.github.io//search" />
    <meta property="og:image" content="https://JaeHong2.github.io//assets/built/images/main-image.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="모르면 -> 알때까지 -> 공부해서 -> 해낸다." />
    <meta name="twitter:url" content="https://JaeHong2.github.io//" />
    <meta name="twitter:image" content="https://JaeHong2.github.io//assets/built/images/main-image.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="오늘의 공부기록" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "오늘의 공부기록",
        "logo": "https://JaeHong2.github.io//"
    },
    "url": "https://JaeHong2.github.io//search",
    "image": {
        "@type": "ImageObject",
        "url": "https://JaeHong2.github.io//assets/built/images/main-image.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://JaeHong2.github.io//search"
    },
    "description": "모르면 -> 알때까지 -> 공부해서 -> 해낸다."
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://JaeHong2.github.io//">오늘의 공부기록</a>
            
        
        
            <!-- 메뉴 바-->
<ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <!--<li class="nav-about" role="menuitem"><a href="/about/">About</a></li>-->
    <li class="nav-python" role="menuitem"><a href="/tag/algorithm/">Algorithm</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/git/">Git</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/java/">Java</a>
    <li class="nav-python" role="menuitem"><a href="/tag/spring/">Spring</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/pt/">Pt</a></li>
    <!--<li class="nav-python" role="menuitem"><a href="/tag/etc/">Etc</a></li>-->
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "pt-1": {
        "title": "21 01 09",
            "author": "jaehong",
            "category": "",
            "content": "DI(Dendency Injection)약한 결합과 강한 결합12345678910111213141516171819202122import&nbsp;java.util.Date;&nbsp;public&nbsp;class&nbsp;DI&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;date&nbsp;=&nbsp;new&nbsp;Date();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;getDate(Date&nbsp;d)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;date&nbsp;=&nbsp;d;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;&nbsp;static&nbsp;void&nbsp;User1()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Member&nbsp;m1&nbsp;=&nbsp;new&nbsp;Member();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;&nbsp;static&nbsp;void&nbsp;User2(Member&nbsp;m)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Member&nbsp;m2&nbsp;=&nbsp;m;&nbsp;&nbsp;&nbsp;&nbsp;}}class&nbsp;Member&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;phone;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Member()&nbsp;{}}&nbsp;Colored by Color Scriptercs2.스택(Stack)2-1.스택이란     한 쪽 끝에서만 자료를 넣고 뺄 수 있는 형식의 자료 구조    LIFO2-2 스택 구현다음은 일반적으로 스택에 사용되는 필수적인 메서드 입니다.    push : 스택의 가장 최상위에 데이터를 삽입    pop  : 스택의 가장 최상위에 위치한 데이터를 삭제    Empty : 스텍이 empty 상태인지 확인    clear : 스택에 저장된 모든 데이터를 삭제하고 스택을 초기화    peek : 스택에 가장 최상위에 위치한 데이터를 추출123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public&nbsp;class&nbsp;ArrayStack&nbsp;implements&nbsp;Stack{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;top;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;stackSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;stackArr[];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//생성자에서&nbsp;스택생성&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ArrayStack(int&nbsp;stackSize)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top&nbsp;=&nbsp;-1;&nbsp;//스택&nbsp;포인터&nbsp;초기화&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.stackSize&nbsp;=&nbsp;stackSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stackArr&nbsp;=&nbsp;new&nbsp;int[this.stackSize];&nbsp;//stack&nbsp;배열생성&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//스택이&nbsp;비어있는&nbsp;상태인지&nbsp;확인&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;isEmpty()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(top&nbsp;==&nbsp;-1);&nbsp;//&nbsp;스택&nbsp;포인터가&nbsp;-1인경우&nbsp;true&nbsp;반환&nbsp;값이있으면&nbsp;false&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//스택이&nbsp;가득차있는&nbsp;상태인지&nbsp;확인&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;isFull()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;top&nbsp;==&nbsp;this.stackSize-1;&nbsp;//스택&nbsp;포인터가&nbsp;마지막인덱스와&nbsp;동일한경우&nbsp;true&nbsp;아닌&nbsp;경우&nbsp;false&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//스택에&nbsp;데이터&nbsp;추가&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;push(int&nbsp;item)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(isFull())&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"스택이&nbsp;가득&nbsp;차있습니다.\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stackArr[++top]&nbsp;=&nbsp;item;&nbsp;//다음&nbsp;스택포인터가르키고&nbsp;데이터&nbsp;추가&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Item&nbsp;삽입:&nbsp;\"&nbsp;+&nbsp;item);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//스택의&nbsp;최상위&nbsp;데이터&nbsp;추출&nbsp;후&nbsp;삭제&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;pop()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(isEmpty())&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"스택이&nbsp;비어있습니다.\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Item&nbsp;삭제&nbsp;:&nbsp;\"&nbsp;+stackArr[top]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;stackArr[top--];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO&nbsp;Auto-generated&nbsp;method&nbsp;stub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//스택의&nbsp;최상위&nbsp;데이터&nbsp;추출&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;peek()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(isEmpty())&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"스택이&nbsp;비어있습니다.\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Item&nbsp;추출&nbsp;:&nbsp;\"&nbsp;+&nbsp;stackArr[top]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO&nbsp;Auto-generated&nbsp;method&nbsp;stub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;stackArr[top];&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//스택&nbsp;초기화&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;clear()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(isEmpty()){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"스택이&nbsp;비어있습니다.\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top&nbsp;=&nbsp;-&nbsp;1;&nbsp;//스택&nbsp;포인터&nbsp;초기화&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stackArr&nbsp;=&nbsp;new&nbsp;int[this.stackSize];&nbsp;//새로운&nbsp;스택&nbsp;생성&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"스택&nbsp;초기화&nbsp;완료\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//스택내용&nbsp;모두&nbsp;출력&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;printStack()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(isEmpty())&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"스택이&nbsp;비어있습니다.\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(\"Stack&nbsp;list&nbsp;:&nbsp;\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;&nbsp;i&lt;=top;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(stackArr[i]&nbsp;+&nbsp;\"&nbsp;\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;stackSize&nbsp;=&nbsp;5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ArrayStack&nbsp;arrStack&nbsp;=&nbsp;new&nbsp;ArrayStack(stackSize);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.push(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.printStack();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.push(2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.printStack();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.push(3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.printStack();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.pop();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.printStack();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.pop();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.printStack();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.peek();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.printStack();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.clear();&nbsp;&nbsp;&nbsp;&nbsp;}}Colored by Color ScriptercsResult2-3 스택의 사용사례    재귀 알고리즘    웹 방문기록(뒤로가기)    후위 표기법 계산    역순 문자열 만들기팩토리얼 구하기 (Factorial)!static int factorial(int n) {    int result = 1;    for(int i= n; i &gt;= 1; i--) {    result *= i;    }    return result;}그리고 이코드를 재귀 함수로 표현해보면 만약 5! 을 구해야된다고 가정을하면factorial(5) = 5 *   4 * 3 * 2 * 1 = 5 * factorial(4);factorial(4) = 4 *   3 * 2 * 1 = 4 * factorial(3);factorial(3) = 3 *   2 * 1 = 3 * factorial(2);factorial(2) = 2 *   1 = 2 * factorial(1);factorial(1) = 1여기서부터는 점화식이 보이기 시작한다. 저 규칙대로하면 factorial(n) = n * factorial(n-1)static int factorial(int n) {    if(n == 1) {  //BaseCase        return 1;    }    return n * factorial(n-1);}2-5 시간복잡도            Insert, Delete        O(1)                Search        O(n)    References.    https://8boknote.tistory.com/67    https://im-developer.tistory.com/121    http://wonwoo.ml/index.php/post/1571",
        "url": "/pt-1"
    }
    ,
    
    "git-error-403": {
        "title": "error 403",
            "author": "jaehong",
            "category": "",
            "content": "Git requested URL returned Error 403 해결방법발생이유2021년 팀 스터디를 시작하기위해 목표설정을 .md파일에 적고    push 하려는데 Git requested URL returned Error 403에러가 나왔다.!두둥..    서칭을 해보니 발생이유는 다양하다고 하나 나의 경우에는 접근 권한을 부여하지 않아 그런거 같았다.!해결방법권한을 부여 받고 아래코드로 깃허브 레퍼지토리에 대한 접근 인증을 받으니 해결됬다.git remote set-url origin (git 레포 url)    그리고 git 레포 url를 가지고올때 ctrl+c +v 했는데 그럴경우     fatal: protocol 'https' is not supported에러가 발생하였다.    붙여넣기시 그대로 문자열이 출력이되지않았다. 결론은 직접쳐보자!!References.    https://cheonjoosung.github.io/blog/git-push-error",
        "url": "/git-error-403"
    }
    ,
    
    "git-basic": {
        "title": "브랜치(Branch)",
            "author": "jaehong",
            "category": "",
            "content": "공부 목표    브랜치(Branch)에 대해 공부해보자!브랜치란??    여러 개발자들이 동시에 다양한 작업을 할 수 있게 만들어주는 기능    각자 독립적인 영역(저장소) 안에서 소스코드 변경 가능    각각의 브랜치는 다른 브랜치의 영향을 받지 않음    각각의 브랜치는 다른 브랜치와 병합(Merge)함으로 하나의 브랜치로 모을 수 있다.    메인 브랜치에서 자신의 전용 브랜치 생성 후 작업이 완료되면 메인 브랜치에    자신의 브랜치 변경 사항 적용한다. 이렇게 함으로 독립적으로 작업 수행이 가능하고    그결과들을 하나로 모아 나가게 할 수 있다. 그리고 작업 단위(브랜치가) 남아 있어    문제가 발생했을 때 원인이되는 작업을 찾을 수 있다.master 브랜치저장소를 처음만들면 Git은 'master'라는 이름의 브랜치를 만든다!    새로운 브랜치를 만들어서 다른 브랜치를 선택(Checkout)하지 않는 이상    모든 작업은 'master 브랜치'에서 이루어진다.브랜치 종류통합 브랜치통합 브랜치는 언제든 배포할 수 있는 버전을 만들 수 있어야 하는 브랜치이다.    늘 안정적인 상태로 유지하는 것이 중요하다고 한다.    여기서 안정적인 상태는 모든 기능이 정상적으로 작동하는 것을 말한다.    일반적으로 저장소를 처음생길때 만들어진 'master' 브랜치를 통합 브랜치로 사용한다!토픽 브랜치기능 추가,버그 같은 단위의 작업을 위한 브랜치, 여러개의 토픽 브랜치 생성 가능!    앞서 말했듯 토픽 브랜치 기능이 완성되면 통합 브랜치에 병합하는 방식으로 진행    다른말로 Feature branch라고도 함!References.    https://backlog.com/git-tutorial/kr/",
        "url": "/git-basic"
    }
    ,
    
    "java-collection-framework": {
        "title": "컬렉션 프레임워크(Collection FrameWork)",
            "author": "jaehong",
            "category": "",
            "content": "컬렉션 프레임워크란앞서 배열은 연관되어있는 데이터를 그룹핑해서 관리하기 위한 수단 이라고 배웠었다.    그러나 배열이 가지고 있는 한계(배열의 크기)가 있고 이를 보안한 도구가 컬렉션 프레임워크다.컬렉션 프레임워크 중 하나인 ArrayList를 살펴보자public static void main(String args[]){    String[] arrObj = new String[2];    arrObj[0] = \"one\";    arrObj[1] = \"two\";    arrObj[2] = \"three\"; //컴파일 에러 1.    ArraryList al = new ArraryList();    al.add(\"one\");    al.add(\"two\");    al.add(\"three\");    for(int i =0 ; i&lt;al.size(); i++)){        String value = al.get(i);//컴파일 에러 2.        System.out.println(value);    }}    위에 코드에서 위에는 일반적인 배열이고 밑에는 ArrayList로 작성하였다.    add메서드를 통하여 리스트에 인자로 전달된 객체를 추가하고, get(int index)로 인덱스 위치에 있는 객체를 리턴받는다.    분명 al.add(\"one\")에서 문자열을 추가 시켰다고 생각했다. 그래서 문자열을 담으려고 했고 그러나 컴파일에러가        난이유는 add 메소드는 어떠한 형태의 데이터타입도 수용할 수 있는 형태의 메소드이기 때문에 인자값이 Object여야한다.        왜냐하면 Object는 모든 데이터 타입의 조상? 이기때문이다. 그래서 형변환을 통해 (String)al.get(i) 데이터 타입을 맞춰주어야한다.그러나 (String)al.get(i) 이방식은 옛날 방식이고     타입의 안정성이 떨어진다고 하여    컬렉션 프레임워크에서 제네릭이라는 문법적 수단을 채택    ArraryList&lt;String&gt; al = new ArraryList()&lt;String&gt;;    al.add(\"one\");    al.add(\"two\");    al.add(\"three\");    for(int i =0 ; i&lt;al.size(); i++)){    String value = al.get(i);    System.out.println(value);}인터페이스    인터페이스란 .. 개발코드와 객체가 서로 통신 하는 접점이다.    개발 코드는 객체의 내부구조를 몰라도 인터페이스의 메소드만 알고있으면된다.인터페이스 역할    개발 코드가 객체에 종속되지 않게 하여 객체를 교체 할 수 있도록 함.    개발 코드 변경없이 리턴 값 또는 실행 내용이 다양해 질수있다.(다형성)인터페이스 구성멤버    상수, 추상메소드    Java 8 부터는 default 메소드, 정적 메소드상수 필드 선언    인터페이스는 상수 필드만 선언가능    인터페이스에 선언된 모든 필드는 public static final(상수)의 특징을 가짐     상수명은 대문자    선언과 동시에 초기화 (static 블록을 작성할수없으므로}추상 메소드 선언    인터페이스의 메소드는 기본적으로 실행 블록이 없는 추상 메소드로 선언한다.    public abstract를 생략하더라도 컴파일 과정에서 자동적으로 붙음public interface RemoteControl{int MAX_VOLUME = 10;int MIN_VOLUME =0;public abstract void turnOn();void turnOff();\t//public abstract 생략void setVolume(int volume); //public abstract 생략}디폴트 메소드 선언    자바 8 에서 추가된 인터페이스의 새로운 멤버    [public]이 기본타입으로 default를 붙어야 생성된다.public interface RemoteControl{    default void setMute(boolean mute){    if(mute){        System.out.println(\"무음 처리\");    }else{        System.out.println(\"무음 해제\");    }}정적 메소드 선언public interface RemoteControl{    static void emptyBattery(){        System.out.println(\"배터리가 다 소모 되었습니다.\");    }}References.    https://www.hanbit.co.kr/",
        "url": "/java-collection-framework"
    }
    ,
    
    "spring-di-2": {
        "title": "다양한 의존 주입",
            "author": "jaehong",
            "category": "",
            "content": "공부 목표    다양한 의존객체 주입 방법에 대해 알아보자!생성자를 이용한 의존 객체 주입 왼쪽에 있는 자바코드를 .xml파일로 만든것이다.    생성자에 객체를 주입시 constructor-arg 사용하고 ref에 참조대상을 적는다.    즉 객체가 생성될때 studentDao 객체가 주입이된다.setter를 이용한 의존객체 주입    위와 같이 왼쪽의 자바코드를 .xml파일로 만든것이며     만들때 property name 속성값을 적을때에 해당하는 setter 이름에서    set을 때고  앞에글자를 소문자로 setJdbcUrl -&gt; jdbcUrlReferences.    ",
        "url": "/spring-di-2"
    }
    ,
    
    "spring-di": {
        "title": "DI(Dependency Injection)",
            "author": "jaehong",
            "category": "",
            "content": "공부 목표    DI(Dependency Injection) 알기Spring 프레임워크    프레임 워크는 마치 네이게이션과 같다.    길 탐색은 네비가 하고 안내를 들은 사용자는 운전만 하면됨Spring 에서 제공하는 모듈    spring-core : DI, IoC 제공    aop : AOP 구현 기능 제공    jdbc : DB를 쉽게 다룰 수 있는 기능 제공    tx : 트랜젝션 관련 기능제공    webmvc : MVC구현 기능 제공    그리고 이러한 모듈을 사용하려면 .xml 파일등에 명시하면 자동으로 라이브러리를 다운받는다.스프링 컨테이너(IoC)스프링에서 객체를 생성,조립하는 컨테이너로,   컨테이너를 통해 생성된 객체를 빈(Bean)이라고 부른다.스프링 파일 구조    스프링 프로젝트 Root                    src                                    main                                                    java : .java파일 관리                            resources : 자원관리 폴더 .xml or property file                                                    pom.xml : 각각의 스프링프로젝트는 pom.xml 파일을 가지고있고 외부 repository에 있는 필요한 library를                내가 개발중인 프로젝트에 쉽게 다운로드 할 수 있게 도와주는 파일이다.        .xml 파일에서 객체 생성&lt;bean id = \"id값\" class=\"패키지명.클래스파일명\"/&gt;    Java에서는 new 키워드를 사용해서 객체를 생성했다.    Spring에서는 bean 태그 위에서 자동으로 객체가 생성이 되며    객체가 생성됬다는건 메모리에 로드가 됬다는 이야기이고    스프링에서는 메모리가 로드 된 곳을 스프링컨테이너라고 한다.    bean을 생성했으니 이제 java파일에서 객체를 실행시키려면    1. .xml파일(컨테이너)를 생성    GenericXmlApplicationContext 데이터 타입선언 후 객체생성 및 매개변수로는 .xml경로를 설정하면된다.    GenericXmlApplicationContext ctx = new GenericXmlApplicationContext(\"classpath:apllicationContext.xml\");    2.컨테이너 안에있는 Bean 객체를 가져다가 쓴다.(객체생성은 컨테이너가 알아서 한다.)    클래스명 변수명 = ctx.getBean(\"빈아이디\", 클래스명.class);    ex) TranspotationWalk trans = ctx.geBean(\"tWalk\", TranspotationWalk.class);    ctx.close //자바에서는 외부리소스 사용후 반환 해주어야한다.References.    ",
        "url": "/spring-di"
    }
    ,
    
    "spring-introduce": {
        "title": "스프링 개요",
            "author": "jaehong",
            "category": "",
            "content": "공부 목표    Spring 개요    Spring 모듈    Spring 컨테이너(IOC)Spring 프레임워크    프레임 워크는 마치 네이게이션과 같다.    길 탐색은 네비가 하고 안내를 들은 사용자는 운전만 하면됨Spring 에서 제공하는 모듈    spring-core : DI, IoC 제공    aop : AOP 구현 기능 제공    jdbc : DB를 쉽게 다룰 수 있는 기능 제공    tx : 트랜젝션 관련 기능제공    webmvc : MVC구현 기능 제공    그리고 이러한 모듈을 사용하려면 .xml 파일등에 명시하면 자동으로 라이브러리를 다운받는다.스프링 컨테이너(IoC)스프링에서 객체를 생성,조립하는 컨테이너로,   컨테이너를 통해 생성된 객체를 빈(Bean)이라고 부른다.스프링 파일 구조    스프링 프로젝트 Root                    src                                    main                                                    java : .java파일 관리                            resources : 자원관리 폴더 .xml or property file                                                    pom.xml : 각각의 스프링프로젝트는 pom.xml 파일을 가지고있고 외부 repository에 있는 필요한 library를                내가 개발중인 프로젝트에 쉽게 다운로드 할 수 있게 도와주는 파일이다.        .xml 파일에서 객체 생성&lt;bean id = \"id값\" class=\"패키지명.클래스파일명\"/&gt;    Java에서는 new 키워드를 사용해서 객체를 생성했다.    Spring에서는 bean 태그 위에서 자동으로 객체가 생성이 되며    객체가 생성됬다는건 메모리에 로드가 됬다는 이야기이고    스프링에서는 메모리가 로드 된 곳을 스프링컨테이너라고 한다.    bean을 생성했으니 이제 java파일에서 객체를 실행시키려면    1. .xml파일(컨테이너)를 생성    GenericXmlApplicationContext 데이터 타입선언 후 객체생성 및 매개변수로는 .xml경로를 설정하면된다.    GenericXmlApplicationContext ctx = new GenericXmlApplicationContext(\"classpath:apllicationContext.xml\");    2.컨테이너 안에있는 Bean 객체를 가져다가 쓴다.(객체생성은 컨테이너가 알아서 한다.)    클래스명 변수명 = ctx.getBean(\"빈아이디\", 클래스명.class);    ex) TranspotationWalk trans = ctx.geBean(\"tWalk\", TranspotationWalk.class);    ctx.close //자바에서는 외부리소스 사용후 반환 해주어야한다.References.    https://www.inflearn.com/",
        "url": "/spring-introduce"
    }
    ,
    
    "jsp-board-crud": {
        "title": "게시판 CRUD",
            "author": "jaehong",
            "category": "",
            "content": "게시판 CRUDjsp를 마무리 하면서 전체적인 기능들을 살펴보았다.전체적인 컴포넌트 설계    모든 요청은 일단 Controller로 간다.    Controller단 에서 DB에 대한 접근이 필요하다면 Command로 간다.    Command 단에서는 Dao에 대한 접근과 필요하다면 화면에 DB에 대한 정보를 JSP로 넘기기위해 request.setAttribute 사용이제 전체적인 코드를 살펴보자.BFrontController.java@WebServlet(\"*.do\")    Servelt mapping을 하기위해 선언되었다.    mapping을 하는 이유는 보안 때문이다.         기존경로가 http://localhost:8080/프로젝트명/servlet/패키지명.클래스명 이라고 자세히 정보를 나타내게되면 보안상으로 취약하다고한다.    그래서 http://localhost:8080/프로젝트명/URL명 으로 간단하게 변경 하는 것이다.     .jsp는 localhost:8080/프로젝트명/파일명.jsp 치면 나오지만        .java 파일은 그렇지 않다.        (매핑 없이 실행해보면 그 경로의 파일을 찾지 못한다고 오류가 난다. )        그래서 실행할 수 있도록 매핑을 하는 것이고,        그 매핑을 함으로써 .jsp에서 매핑된 이름으로 .java 파일에 요청을 보낼 수 있다고 한다.    또한 mapping방법은 @(어노테이션 뿐만아니라) WebContent폴더 안에 web.xml 파일을 이용해 등록하는 방법도 있다.public class BFrontController extends HttpServlet {    private static final long serialVersionUID = 1L;    public BFrontController() {        super();    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        actionDo(request,response);    }    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    actionDo(request,response);}    HttpServlet을 상속받는 클래스는 doGet, doPost 메소드를 오버라이딩할 수 있기에 이 클래스는 서블릿으로 동작할 수 있다.    그리고 doGet, doPost 메서드는 모두 HttpServletRequest와 HttpServletResponse 객체를 매개변수로 가지고 있다.    이 두 객체는 서블릿과 클라이언트 사이를 연결해주는 중요한 객체들이다.private void actionDo(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    request.setCharacterEncoding(\"UTF-8\");    String viewPage = null; //최종적으로 페이지가 호출될것인지    BCommand command =null;//model객체로 부터 로직을수행하기위함    String uri = request.getRequestURI();    String conPath = request.getContextPath();    String com = uri.substring(conPath.length());    if(com.equals(\"/write_view.do\")) {        viewPage = \"write_view.jsp\";    }else if(com.equals(\"/write.do\")) {        command = new BWriteCommand();        command.execute(request,response);        viewPage = \"list.do\";    }else if(com.equals(\"/list.do\")) {        command = new BListCommand();        command.execute(request,response);        viewPage = \"list.jsp\";    }else if(com.equals(\"/content_view.do\")) {        command = new BContentCommand();        command.execute(request,response);        viewPage = \"content_view.jsp\";    }else if(com.equals(\"/modify.do\")) {        command = new BModifyCommand();        command.execute(request,response);        viewPage = \"list.do\";    }else if(com.equals(\"/delete.do\")) {        command = new BDeleteCommand();        command.execute(request,response);        viewPage = \"list.do\";    }else if(com.equals(\"/reply_view.do\")) {        command = new BReplyViewCommand();        command.execute(request,response);        viewPage = \"reply_view.jsp\";    }else if(com.equals(\"/reply.do\")) {        command = new BReplyCommand();        command.execute(request,response);        viewPage = \"list.do\";    }    RequestDispatcher dispatcher = request.getRequestDispatcher(viewPage);    dispatcher.forward(request, response);}    actionDo 메서드는 요청에 맞는 Command로 보내는 역할을 한다.    request.getRequestURI()에는 /패키지명/매핑명 을 가지고있고    request.getContextPath()에는 /패키지명 있기에    uri.substring(conPath.length())는 결국 /매핑명만 가지게 된다.    이렇게 매핑명만 분리해서 문자열 비교로 해당 요청에맞는 command로 넘겨주게 된다.    RequestDispatcher는 앞서 command에서 가공된 DB값들을 가지고 View단으로 넘겨주는 역할을 한다.BCommand.javapublic interface BCommand {    void execute(HttpServletRequest request, HttpServletResponse response);}    해당 기능을 강제로 구현함과 메서드명을 통일함으로 interface 사용    모든 Command는 BCommand를 상속 한다.    request, response 객체를 사용하기 위함BWriteCommand.javapublic class BWriteCommand implements BCommand{    @Override    public void execute(HttpServletRequest request, HttpServletResponse response) {        // TODO Auto-generated method stub        String bName = request.getParameter(\"bName\");        String bTitle = request.getParameter(\"bTitle\");        String bContent = request.getParameter(\"bContent\");        BDao dao = new BDao();        dao.write( bName, bTitle, bContent);    }}BListCommand.javapublic class BListCommand implements BCommand {    @Override    public void execute(HttpServletRequest request, HttpServletResponse response) {        // TODO Auto-generated method stub        BDao dao = new BDao();        ArrayList&lt;BDto&gt; dtos = dao.list();        request.setAttribute(\"list\", dtos);    }}BContentCommand.javapublic class BContentCommand implements BCommand {@Overridepublic void execute(HttpServletRequest request, HttpServletResponse response) {    // TODO Auto-generated method stub    String bId = request.getParameter(\"bId\");    BDao dao = new BDao();    BDto dto = dao.contentView(bId);    request.setAttribute(\"content_view\", dto);    }}    Main화면에서 여러개의 글 목록중 특정 글에대한 정보를 출력하기 위한 클래스    .jsp 단에서 value에 저장된값을 dao로 넘겨줌BModifyCommand.javapublic class BModifyCommand implements BCommand {    @Override    public void execute(HttpServletRequest request, HttpServletResponse response) {        // TODO Auto-generated method stub        String bId\t= request.getParameter(\"bId\");        String bName = request.getParameter(\"bName\");        String bTitle = request.getParameter(\"bTitle\");        String bContent = request.getParameter(\"bContent\");        BDao dao = new BDao();        dao.modify(bId, bName, bTitle, bContent);    }}BDeleteCommand.javapublic class BDeleteCommand implements BCommand {@Overridepublic void execute(HttpServletRequest request, HttpServletResponse response) {    // TODO Auto-generated method stub    String bId\t= request.getParameter(\"bId\");    BDao dao = new BDao();    dao.delete(bId);    }}    순서대로 C, R(글 전체출력,세부정보출력), U, D    Read 같은경우는 Dao를 통해 가져온 값들을 화면상에 출력해주어야하기에 request.setAttribute에 값을 담아서 보냄    Create Update는 화면단에서 입력된 값들을 DB상에 저장하기위해 request.getAttribute로 값을 받아서 Dao로 보냄    Update,Delete, Read(세부정보출력)시 특정 글의 id값을 가져와서 Dao로 보냄BDao.java    DataSource dataSource;    public BDao() {        try {            Context context = new InitialContext();            dataSource = (DataSource) context.lookup(\"java:comp/env/jdbc/Oracle11g\");            }catch(Exception e) {                e.printStackTrace();        }    }    DBCP를 사용하기위해 Tomcat context.xml에 설정한 DB 정보들 java코드로 연결하기 위해        JNDI(Java Naming and Directory Interface) 자바 네이밍 API를 사용한다. 네이밍 패키지의 클래스를        가지고 이름으로 객체를 획득하는 것을 말한다.        쉽게말해 이름을 이용해서 원하는 정보 혹은 자원(Connection)을 찾을 수 있는 서비스    public void write(String bName, String bTitle, String bContent) {    Connection connection = null;    PreparedStatement psmt = null;    try {        connection = dataSource.getConnection();        String query = \"insert into mvc_board (bId, bName, bTitle, \"        + \"bContent, bHit, bGroup, bStep, bIndent)\"        + \"values (mvc_board_seq.nextval, ?, ?, ?, 0, mvc_board_seq.currval, 0, 0)\";        psmt = connection.prepareStatement(query);        psmt.setString(1, bName);        psmt.setString(2, bTitle);        psmt.setString(3, bContent);        int rn = psmt.executeUpdate(); //정상적으로 insert시 1반환    }catch (Exception e) {        // TODO: handle exception        e.printStackTrace();    }finally {        try {            if(psmt != null)psmt.close();            if(connection != null) connection.close();        }catch (Exception e2) {            e2.printStackTrace();       }    }}    SQL문장을 실행시키기 위해 Connection 객체에 위에서 생성한 db정보를 넘겨준다.    문자열로 쿼리를 작성하는데 ?자리는 매개변수로 받아온 값들이 들어갈수있도록 setString 메서드로 처리한다.        setString(정수(물음표 자리), 값)        executeUpdate로 정상적으로 쿼리가 실행되었다면 정수값 1을 리턴한다.    catch에서는 예외처리    finally에서는 메모리 해제 &amp; 예외처리를 한다.    Update와 Delete도 이와 비슷한 구조로 처리가 되어 따로 기록하진않았다.public ArrayList&lt;BDto&gt; list(){    ArrayList&lt;BDto&gt; dtos = new ArrayList&lt;BDto&gt;();    Connection connection = null;    PreparedStatement psmt = null;    ResultSet rs = null;    try {        connection = dataSource.getConnection();        String query = \"select bId, bName, bTitle, bContent, bDate, bHit, bGroup, bStep, bIndent \"        +\"from mvc_board \"        +\"order by bGroup desc, bStep asc\";        psmt = connection.prepareStatement(query);        rs = psmt.executeQuery();        while(rs.next()) {            int bId = rs.getInt(\"bId\");            String bName = rs.getString(\"bName\");            String bTitle = rs.getString(\"bTitle\");            String bContent = rs.getString(\"bContent\");            Timestamp bDate = rs.getTimestamp(\"bDate\");            int bHit = rs.getInt(\"bHit\");            int bGroup = rs.getInt(\"bGroup\");            int bStep = rs.getInt(\"bStep\");            int bIndent = rs.getInt(\"bIndent\");            BDto dto = new BDto( bId,  bName,  bTitle,  bContent,  bDate,  bHit,  bGroup,  bStep,  bIndent );            dtos.add(dto);            }    }catch (Exception e) {        e.printStackTrace();    }finally {        try {            if(rs != null) rs.close();            if(psmt != null) psmt.close();            if(connection != null) connection.close();        }catch(Exception e2) {            e2.printStackTrace();        }    }        return dtos;    }    글 목록을 출력하는 Dao 부분이다.    ResultSet은 Select의 결과 값을 저장하는 객체이고, 데이터타입은 dto이며,        ArrayList를 사용, 각각의 글에대한 정보들을 담아 ReturnType으로 넘겨 준다.References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/    https://gmlwjd9405.github.io/2018/10/28/servlet.html    http://blog.naver.com/PostView.nhn?blogId=smilennv&amp;logNo=220454626217    RequestDispatcher와 sendRedirect 알기",
        "url": "/jsp-board-crud"
    }
    ,
    
    "beakjoon-10809": {
        "title": "알파벳 찾기",
            "author": "jaehong",
            "category": "",
            "content": "문제알파벳 소문자로만 이루어진 단어 S가 주어진다. 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오.입력첫째 줄에 단어 S가 주어진다. 단어의 길이는 100을 넘지 않으며, 알파벳 소문자로만 이루어져 있다.출력각각의 알파벳에 대해서, a가 처음 등장하는 위치, b가 처음 등장하는 위치, … z가 처음 등장하는 위치를 공백으로 구분해서 출력한다.만약, 어떤 알파벳이 단어에 포함되어 있지 않다면 -1을 출력한다. 단어의 첫 번째 글자는 0번째 위치이고, 두 번째 글자는 1번째 위치이다.예제입력1baekjoon예제 출력1 0 -1 -1 2 -1 -1 -1 -1 4 3 -1 -1 7 5 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1문제생각a~z까지 입력값에 있으면 입력값에 대한 위치를 출력0부터 시작, 입력한 문자중 없으면 -1중복된 2번째 문자부터는 무시codeimport java.io.*;public class Main {    public static void main(String args[]) throws IOException{        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        String s = br.readLine();        for(char c='a';c&lt;='z';c++) { //a~z까지            System.out.print(s.indexOf(c)+\" \");            // indexOf() :  특정 문자나 문자열이 앞에서부터 처음 발견되는 인덱스를 반환하며            //                  찾지 못하면 -1을 반환한다..        }    }}문제출처    백준알고리즘 https://www.acmicpc.net/problem/10809&gt;",
        "url": "/beakjoon-10809"
    }
    ,
    
    "jsp-mvc": {
        "title": "MVC 패턴",
            "author": "jaehong",
            "category": "",
            "content": "MVC    Model, View, Controller 약자    각각의 기능들이 상호작용mvc model1View + Controller = .jspmvc model2모두 모듈화 되어있는 형태References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-mvc"
    }
    ,
    
    "jsp-uri-pattern": {
        "title": "uri-pattern",
            "author": "jaehong",
            "category": "",
            "content": "디렉터리 패턴서블릿을 만들면 .xml or annotation을 이용해서 mapping 하는 방식을 공부했었는데디렉터리 형태로 서버의 해당 컴포넌트(서블릿)을 찾아서 실행하는 구조를 디렉터리 패턴이라고 한다.확장자 패턴확장자 형태로 서버의 해당 컴포넌트를 찾아서 실행하는 구조확장자 패턴은 두가지가있다.    FrontController 패턴    Command 패턴FrontControllerCommandReferences.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-uri-pattern"
    }
    ,
    
    "jsp-jstl": {
        "title": "JSTL",
            "author": "jaehong",
            "category": "",
            "content": "개요JSP 경우 HTML 태그와 같이 사용하므로 코드 가독성이 떨어진다.이런 단점을 보완하고자 태그 라이브러리인 JSTL 등장!Tomcat 컨테이너에 포함 되어있지 않아 별도 설치필요하다.나의 경우 링크 여기를 통해서jakarta-taglibs-standard-1.1.2.zip을 다운하였다.JSTL 라이브러리JSTL에서는 5가지 라이브러리 제공    Core    XML Processing    I18N formatting    SQL    FunctionsCore기본적인 라이브러리로 출력,제어,반복문 기능들이 포함페이지 지시자를 사용한 페이지 속성선언&lt;%@ taglib uri = http://java.sun.com/jsp/jstl/core prefix=”c” %&gt; 보통 앞글자로 prefix정함출력 태그    &lt;c:out value=\"출력값\" default=\"기본값\" escapeXml=\"true or false\"/&gt;변수 설정 태그    &lt;c:set var=\"변수명\" value=\"설정값\" target=\"객체\" property=\"값\" scope=\"범위\"/&gt;변수 제거 태그    &lt;c:remove var=\"변수명\" scope=\"범위\"/&gt;예외 처리 태그    &lt;c:catch var=\"변수명\"/&gt;제어문(if)    &lt;c:if test=\"조건\" var=\"조건 처리 변수명\" scope=\"범위\"/&gt;제어문(switch)    &lt;c:choose&gt;        &lt;c:when test=\"조건\"&gt;처리내용&lt;/c:when&gt;        &lt;c:oherwise&gt;처리 내용&lt;/c:oherwise&gt;    &lt;/c:choose&gt;반복문(for)문    &lt;c:forEach itmes=\"객체명\" begin=\"시작 인덱스\" end=\"끝 인덱스\" step=\"증감식\"               var=\"변수명\" varStatus=\"상태변수\"/&gt;페이지 이동 태그    &lt;c:redirect url =\"url\"/&gt;파라미터 전달 태그    &lt;c:param name=\"파라미터명\" value=\"값\"/&gt;예제&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"c\" uri =\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;c:set var=\"varName\" value=\"varValue\"/&gt;varName : &lt;c:out value = \"${varName }\"/&gt;&lt;br/&gt;&lt;c:remove var = \"varName\"/&gt;varName : &lt;c:out value =\"${varName }\"/&gt;&lt;hr/&gt;&lt;c:catch var =\"error\"&gt;    &lt;%=2/0 %&gt;&lt;/c:catch&gt;&lt;br/&gt;&lt;c:out value=\"${error}\"/&gt;&lt;hr/&gt;&lt;c:if test=\"${1+2==3}\"&gt;    1 + 2 = 3&lt;/c:if&gt;&lt;c:if test=\"${1+2!=3}\"&gt;    1 + 2 != 3&lt;/c:if&gt;&lt;hr/&gt;&lt;c:forEach var=\"fEach\" begin=\"0\" end=\"30\" step=\"3\"&gt;    ${fEach}&lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt;References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-jstl"
    }
    ,
    
    "jsp-el-html": {
        "title": "EL(Expression Language)",
            "author": "jaehong",
            "category": "",
            "content": "Expression Language    표현식 또는 액션 태그를 대신해서 값을 표현하는 언어    코드의 간결화를 위해 사용표현식${1+2}&lt;br/&gt;${1-2}&lt;br/&gt;${(1&gt;2) ? 1 : 2 }&lt;br/&gt;&lt;br/&gt;&lt;%= 1+2 %&gt;&lt;br/&gt;&lt;%= 1-2 %&gt;&lt;br/&gt;&lt;%= (1&gt;2) ? 1 : 2 %&gt;======================================================태그이름 :   &lt;jsp:getProperty name=\"member\" property=\"name\" /&gt;아이디 : &lt;jsp:getProperty name=\"member\" property=\"id\" /&gt;비번:   &lt;jsp:getProperty name=\"member\" property=\"pw\" /&gt;&lt;br/&gt;이름 :   ${member.name }아이디 : ${member.id }비번:   ${member.pw }내장객체    pageScope : page 객체를 참조하는 객체    requestScope : request 객체를 참조하는 객체    sessionScope : session 객체를 참조하는 객체    applicationScope : application 객체를 참조하는 객체    param : 요청 파라미터를 참조하는 객체    paramValues : 요청 파라미터(배열)을 참조하는 객체    initParam 초기화 파라미터를 참조하는 객체    cookie : cookie 객체를 참조하는 객체예제1입력 폼&lt;form action=\"objelOk.jsp\"&gt;    아이디 : &lt;input type=\"text\" name =\"id\"&gt;    비밀번호 : &lt;input type=\"password\" name =\"pw\"&gt;    &lt;input type=\"submit\" value=\"login\"&gt;&lt;/form&gt;출력 폼&lt;%String id = request.getParameter(\"id\");String pw = request.getParameter(\"pw\");%&gt;아이디 &lt;%= id %&gt;&lt;br/&gt;비번 &lt;%= pw %&gt;&lt;hr/&gt;&lt;!-- 내장객체 param사용 --&gt;아이디 ${param.id }&lt;br/&gt; &lt;!-- request.getParameter(\"id\");과 동일 --&gt;비밀번호 ${param.pw }&lt;br/&gt;아이디 ${param[\"id\"]}&lt;br/&gt; &lt;!-- request.getParameter(\"id\");과 동일 --&gt;비밀번호 ${param[\"pw\"]}&lt;br/&gt;=======================&lt;!--내장 객체--&gt;applicationScope : ${applicationScope.application_name }&lt;br/&gt;sessionScope : ${sessionScope.session_name }&lt;br/&gt;pageScope : ${pageScope.page_name }&lt;br/&gt;requestScope : ${requestScope.request_name }예제2&lt;!-- web.xml파일에서 context-param에 등록된 데이터를 들고 올때--&gt;&lt;!-- 8-2에서 배운 ServletContext --&gt;&lt;%  String id = getServletContext().getInitParameter(\"con_name\");    String pw = getServletContext().getInitParameter(\"con_id\");    String path = getServletContext().getInitParameter(\"con_pw\");%&gt;&lt;%= id %&gt;&lt;br/&gt;&lt;%= pw %&gt;&lt;br/&gt;&lt;%= path %&gt;&lt;br/&gt;============================&lt;!-- EL을 사용해서 가지고올때 --&gt;${initParam.con_name }&lt;br/&gt;${initParam.con_id }&lt;br/&gt;${initParam.con_pw }&lt;br/&gt;References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-el.html"
    }
    ,
    
    "jsp-file-upload-html": {
        "title": "file upload",
            "author": "jaehong",
            "category": "",
            "content": "fileForm.jsp&lt;form action = \"fileFormOk.jsp\" method=\"post\" enctype=\"multipart/form-data\"&gt;    파일 : &lt;input type=\"file\" name=\"file\"&gt;&lt;br/&gt;    &lt;input type=\"submit\" value=\"File Upload\"&gt;&lt;/form&gt;    &lt;input type=\"file\"&gt; : 파일을 선택할 수 있는 창을 만든다.    &lt;form method=\"post\"&gt; : 형태로 전송한 폼에 담겨진 파라미터들은 request 객체를 통해 이름에 해당되는 값을 얻어낼 수 있다 .    하지만 enctype=\"multipart/form-data\"로 지정한 폼은 request객체로 파라미터의 값을 얻어낼 수 없다.multipart/form-data 전송한 양식의 파라미터들에 대한 값을 얻어내기 위해특별한 컴포넌트가 필요하다!http://www.servlets.com/cos/여기서 cos 파일을 다운 받아 cos/lib/cos.jar 파일을 WebContent/WEB-INF/lib에 복사한다.fileFormOk.jsp실질적인 업로드가 진행되는 jsp 파일&lt;%@page import=\"java.util.Enumeration\"%&gt;&lt;%@page import=\"com.oreilly.servlet.MultipartRequest\"%&gt;&lt;%@page import=\"com.oreilly.servlet.multipart.DefaultFileRenamePolicy\"%&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"pageEncoding=\"UTF-8\"%&gt;&lt;%    String path  = request.getRealPath(\"fileFolder\"); //파일이 실제로 저장되는 폴더명    int size = 1024 * 1024 * 10; //10M    String file=\"\";    String oriFile = \"\";    try{        //MultipartRequest객체가 파일 업로드를 담당        //form에서 가져온 인자값을 얻기위해        //업로드될 위치        //업로드 최대크기 설정 초과할경우 exception        //한글        //이름이 같은 파일을 업로드할경우 파일이름 변환        MultipartRequest multi =  new MultipartRequest(request, path, size, \"utf-8\", new DefaultFileRenamePolicy());        Enumeration files = multi.getFileNames(); //올린파일이름들을 얻는다.        String str = (String)files.nextElement();//파일이름 저장        file = multi.getFilesystemName(str); //파일이름이 중복되어있을때 처리        oriFile = multi.getOriginalFileName(str);    }catch(Exception e){        e.printStackTrace();    }%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;file upload success;&lt;/body&gt;&lt;/html&gt;References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-file-upload.html"
    }
    ,
    
    "jsp-member-crud-html": {
        "title": "회원 CRUD",
            "author": "jaehong",
            "category": "",
            "content": "흐름도MemberDao.javalogin.jsploginOk.jspjoin.jspjoinOk.jspmain.jspmodify.jspmodifyOk.jsplogout.jspmember.jsReferences.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-member-crud.html"
    }
    ,
    
    "beakjoon-1065": {
        "title": "한수",
            "author": "jaehong",
            "category": "",
            "content": "한수문제어떤 양의 정수 X의 각 자리가 등차수열을 이룬다면, 그 수를 한수라고 한다. 등차수열은 연속된 두 개의 수의 차이가 일정한 수열을 말한다.N이 주어졌을 때, 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력하는 프로그램을 작성하시오.입력110출력99import java.io.*;public class Main {public static void main(String args[]) throws IOException {    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));    int n = Integer.parseInt(br.readLine());    bw.write(check(n) + \"\\n\");    bw.flush();    br.close();    bw.close();    }    static int check(int n) {        int count =0; //정해진입력값에서 한수가 몇개인지        int a[] = new int[3]; //100~ 999자리수를 저장하기위한 배열        for(int i=1; i&lt;=n; i++) {//  1~ 입력만큼            if(i &lt; 100 ) count = i; //1~99는 모두 한수            else if(i == 1000) break; //1000은 한수가 아님            else {                int k = 0, t = i;                while (t &gt; 0) { //일의자리수를 배열에 넣기위한 로직                a[k] = t % 10;                t /= 10;                k++;            }            if (a[0] - a[1] == a[1] - a[2]) //공차가 같으면 한수            count++;        }    }        return count;    }}처음에는 문제 이해를 못하였는데 입력값으로 주어진 수 만큼 예를 들어 110이면 1~110만큼 수 중에    한수 즉 123 같이 각 자리의 수만봤을때 1 2 3 이 1씩증가되있으므로 등차수열에 성립이 된다하여    123은 한수에 포함이 된다.문제출처    백준알고리즘 https://www.acmicpc.net/problem/1065&gt;",
        "url": "/beakjoon-1065"
    }
    ,
    
    "jsp-dbcp-html": {
        "title": "dbcp",
            "author": "jaehong",
            "category": "",
            "content": "커넥션 풀DAO, DTODAO: Data Access Object -&gt; DB로 접근해서 로직수행DTO: Data Transfer Object -&gt; DAO를 이용하여 일반적인 변수에 데이터를 할당하여 사용할수도있지만. 그럴경우 코드가 지저분해진다.                                그래서 데이터만을 모아둔 클래스를 별도로 정의한것을 DTOPreparedStatementsql문 실행을 위해 Statement 객체를 이용했는데, 중복코드가 많아진다는 단점이있어   단점 보안을 위해 PreparedStatement 등장커넥션 풀(DBCP)    DB 부하를 막기위해 Connection 객체를 미리 생성하여 사용    tomcat 컨테이너 안 context.xml 파일에 코드 추가context.xml&lt;Resource        auth=\"Container\"        driverClassName = \"oracle.jdbc.driver.OracleDriver\"        url = \"jdbc:oracle:thin:@localhost:1521:orcl\"        username = \"scott\"        password = \"1234\"        name = \"jdbc/Oracle11g\"        type = \"javax.sql.DataSource\"        maxActive = \"50\"        maxWait = \"1000\"/&gt;References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-dbcp.html"
    }
    ,
    
    "restapi-html": {
        "title": "Rest API란 무엇인가..",
            "author": "jaehong",
            "category": "",
            "content": "rest api란 무엇인가.References.    https://www.hanbit.co.kr/",
        "url": "/restapi.html"
    }
    ,
    
    "beakjoon-4673": {
        "title": "셀프 넘버",
            "author": "jaehong",
            "category": "",
            "content": "셀프넘버public class Main {    public static void main(String[] args){        int[] check = new int[10001];        for (int i = 0; i&lt;10001;++i) {            int n = sum(i); //            if (n&lt;10001 &amp;&amp; check[n]==0) {                check[n]=1;            }        }        StringBuilder a = new StringBuilder();        for (int i =0; i&lt;10001; ++i) {            if(check[i]==0) {            a.append(i).append('\\n');            }        }        System.out.println(a);}    public static int sum(int number) {        int sum = number;        while (number!=0) {            sum += number%10;            number/=number/10;        }        return sum;    }}문제출처    백준알고리즘 https://www.acmicpc.net/problem/4673&gt;",
        "url": "/beakjoon-4673"
    }
    ,
    
    "beakjoon-4344": {
        "title": "평균은 넘겠지",
            "author": "jaehong",
            "category": "",
            "content": "평균은 넘겠지import java.io.*;import java.util.StringTokenizer;/* 1. 테스트 케이스 개수 입력* 2. 학생수와 점수 입력* 3. 첫번째 입력한값이 학생수 저장* 4. 각테스트 케이스마다 합과 평균이상인 학생이 다르므로 초기화* 5. 배열에 점수저장 및 점수합, 평균값 계산* 6. 각 점수와 평균을 비교해서 평균이 넘으면 count;* 7. 평균을 넘은사람/총인원 *100 &amp; 소수점 3째자리 반올림해서 출력.*/public class Main{    public static void main(String args[]) throws IOException{        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));        StringTokenizer st;        //1        int c = Integer.parseInt(br.readLine());        for(int i=0; i&lt;c; i++) {            //2            st = new StringTokenizer(br.readLine());            //3            int studentN = Integer.parseInt(st.nextToken());            int[] arr = new int[studentN];            //4            int count =0;            int sum=0;            //5            for(int j=0; j&lt;studentN; j++) {                arr[j] = Integer.parseInt(st.nextToken());                sum += arr[j];            }            double avg = (double)(sum/studentN);            //6            for(int value : arr) {                if(value &gt; avg) {                    count++;                }            }            //7            String result = String.format(\"%.3f\", (((double)count/studentN)*100))+\"%\";            bw.write(result + \"\\n\");        }        bw.flush();        br.close();        bw.close();    }}문제출처    백준알고리즘 https://www.acmicpc.net/problem/4344&gt;",
        "url": "/beakjoon-4344"
    }
    ,
    
    "beakjoon-8958": {
        "title": "OX퀴즈",
            "author": "jaehong",
            "category": "",
            "content": "OX 퀴즈import java.io.*;import java.util.*;public class Main{    public static void main(String args[]) throws IOException {        //1. List를 사용해서 동적배열로 입력받기        //2. 저장된 문자열을 split로 문자로 구분후 문자열배열에 저장        //3.O가 연속될때마다 값이 1증감되고 X를 만나면 다시 0에서 시작        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));        List&lt;Object&gt; Array = new ArrayList&lt;Object&gt;();        int n = Integer.parseInt(br.readLine());        int count =0;        int sum=0;        //1.        for(int i =0; i &lt; n; i++) {            Array.add(br.readLine());        }        //2.        String[] str;        for(Object aa : Array) {            count =0;            sum=0;            str = (aa.toString()).split(\"\");        //3.        for(String s : str) {            if(s.equals(\"O\")) {            sum\t+= ++count;            } else {            count =0;            }        }        bw.write(sum +\"\\n\");        }        br.close();        bw.flush();        bw.close();    }}문제출처    백준알고리즘 https://www.acmicpc.net/problem/8958&gt;",
        "url": "/beakjoon-8958"
    }
    ,
    
    "jsp-bean-html": {
        "title": "bean",
            "author": "jaehong",
            "category": "",
            "content": "Java언어의 데이터(속성)과 기능(메소드)로 이루어진 클래스    useBean    setProperty    getPropertyuseBean특정 Bean을 사용한다고 명시 할떄 사용              //id(빈이름) , 클래스 이름 , 스코프 범위&lt;jsp:userBean id =\"student\" class=\"\"com.javalec.ex.Student scope=\"page\"/&gt;set,getPropertyjava s/getter와 같은 역할&lt;jsp:setProperty name=\"student\" property=\"name\" value=\"홍길동\"/&gt;&lt;jsp:getProperty name=\"student\" property=\"name\"/&gt;References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-bean.html"
    }
    ,
    
    "jsp-exception-html": {
        "title": "exception",
            "author": "jaehong",
            "category": "",
            "content": "예외처리1.페이지 지시자를 통한 예외 처리    &lt;%@ page errorPage = \"errorPage.jsp\" %&gt; //1. 해당페이지에서 에러가 발생할시 errorPage.jsp의 내용 출력&lt;%@ page isErrorPage = \"true\" %&gt; &lt;!-- 해당page는 error를 받을 수 있습니다.--&gt;&lt;% response.setStatus(200); %&gt; &lt;!-- 200은 정상적인 페이지를 말함--&gt;&lt;body&gt;    예외페이지 입니다.&lt;br/&gt;    &lt;% exception.getMessage(); %&gt;&lt;/body&gt;2.web.xml을 통한 예외 처리web.xml    &lt;error-page&gt;        &lt;error-code&gt;404&lt;/error-code&gt;        &lt;location&gt;/error404.jsp&lt;/location&gt;    &lt;/error-page&gt;    &lt;error-page&gt;        &lt;error-code&gt;500&lt;/error-code&gt;        &lt;location&gt;/error500.jsp&lt;/location&gt;    &lt;/error-page&gt;References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-exception.html"
    }
    ,
    
    "jsp-cookie-html": {
        "title": "cookie &amp; session &amp; cache",
            "author": "jaehong",
            "category": "",
            "content": "쿠키http 프로토콜의 특징은 웹브라우저에 응답 후 관계를 끊는 것이다.    연결이 끊겼을 때 어떤 정보를 지속적으로 유지하기 위한 수단으로 쿠키를 사용한다.    쿠키는 서버에서 생성하여, 생성된 쿠키는 서버가아닌 클라이언트 측에 저장     4kb로, 300개까지 데이터 정보를 가질 수 있다. 쿠키 생성 -&gt; 속성 설정 -&gt; response 객체에 쿠키 탑재    &lt;%    Cookie cookie = new Cookie(\"id\",id); //쿠키 name, value    cookie.setMaxAge(60); //60초간 지속    response.addCookie(cookie); //쿠키탑재    response.sendRedirect(\"abc.jsp\") // 포워딩    %&gt;&lt;!--forwarding 후--&gt;&lt;%    Cookie[] cookies = request.getCookies(); // 포워딩된 쿠키객체    for(int i=0; i &lt; cookies.length; i++){        String id = cookies[i].getValue();    } 쿠키의 한계 사용자가 임의로 고치거나 지울수있다. 쿠키가 보안상으로 취약 세션    쿠키와 마찬가지로 서버와의 관계를 유지하기 위한 수단    서버상에 객체로 존재 (쿠키는 클라이언트 쪽에 존재)    세션은 서버에서만 접근이 가능 -&gt; 보안이 좋다. , 데이터에 한계가 없다.브라우저 하나당 하나의 객체를 jsp 컨테이너가 자동으로 생성한다. 클라이언트 요청 -&gt; 서버에서는 기한이 짧은 임시키를 브라우저로보내어 쿠키로저장 -&gt; 클라이언트가 사이트 접속할때마다 http요청에 key를 실어 서버로 전송login.html&lt;form  action =\"loginOk.jsp\" method=\"post\"&gt;    아이디: &lt;input type=\"text\" name =\"id\" size=\"10\"&gt;&lt;br/&gt;    비밀번호: &lt;input type=\"password\" name =\"pw\" size=\"10\"&gt;&lt;br/&gt;    &lt;input type=\"submit\" value=\"로그인\"&gt;&lt;/form&gt;loginOk.jsp&lt;%!    String id,pw;%&gt;&lt;%    id =request.getParameter(\"id\");    pw = request.getParameter(\"pw\");    if(id.equals(\"abcde\")&amp;&amp; pw.equals(\"12345\")){        session.setAttribute(\"id\",id);        response.sendRedirect(\"welcome.jsp\");    }else{        response.sendRedirect(\"login.html\");    }%&gt;welcome.jsp&lt;%    Enumeration enumeration = session.getAttributeNames();    while(enumeration.hasMoreElements()){        String sName = enumeration.nextElement().toString();        String sValue = (String)session.getAttribute(sName);        if(sValue.equals(\"abcde\")){            out.println(sValue + \"님 안녕하세요.\" +\"&lt;br/&gt;\");        }    }%&gt;logout.jsp&lt;%    Enumeration enumeration = session.getAttributeNames();    while(enumeration.hasMoreElements()){    String sName = enumeration.nextElement().toString();    String sValue = (String)session.getAttribute(sName);    if(sValue.equals(\"abcde\")) session.removeAttribute(sName);    }%&gt;캐쉬가져오는데 비용이 드는 데이터를 한번가져온뒤에는 임시로 저장    웹캐쉬는 이미지정보를 불러올때 데이터사용량도 발생하고 시간도들기에    사용자가 여러번 방문 할듯한 사이트에서는 한번 받아온 데이터를 사용자의 컴퓨터 or 서버에 저장References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/    얄팍한 코딩사전",
        "url": "/jsp-cookie.html"
    }
    ,
    
    "jsp-action-tag-html": {
        "title": "action tag",
            "author": "jaehong",
            "category": "",
            "content": "액션태그JSP 페이지 내에서 동작을 지시하는 태그forward&lt;!-- main.jsp --&gt;&lt;jsp:foword page=\"sub.jsp\"/&gt;    url은 변경되지 않지만 내용은 forward한 .jsp파일을 따른다.include현재페이지에서 다른 페이지 삽입&lt;jsp:include page = \"include02.jsp\" flush =\"true\"/&gt;paramforward 및 include 태그에 데이터 전달을 목적으로 사용되는 태그&lt;jsp:foward page=\"sub.jsp\"&gt;    &lt;jsp:param name=\"id\" value =\"abcd\"/&gt;    &lt;jsp:param name=\"pw\" value=\"11\"/&gt;&lt;/jsp:foward&gt;&lt;!---값을 받을때-----&gt;&lt;%    id = request.getParameter(\"id\");    pw = request.getParameter(\"pw\");%&gt;References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-action-tag.html"
    }
    ,
    
    "beakjoon-1110": {
        "title": "더하기 사이클",
            "author": "jaehong",
            "category": "",
            "content": "더하기 사이클import java.io.*;public class Main {public static void main(String[] args) throws IOException{    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));    int n =  Integer.parseInt(br.readLine());    int sum =0;    int leftN =0;    int rightN =0;    int result = n;    int a =0;    while(true) {        leftN = result/10;        rightN = result%10;        sum = leftN + rightN;        result = rightN*10 + sum%10;        a++;        if(n == result) {            break;        }    }    bw.write(a +\"\\n\");    bw.flush();    }}문제출처    백준알고리즘 https://www.acmicpc.net/problem/1110&gt;",
        "url": "/beakjoon-1110"
    }
    ,
    
    "java-abstract-interface": {
        "title": "추상클래스와 인터페이스",
            "author": "jaehong",
            "category": "",
            "content": "추상실제들 간에 공통되는 특성을 추출ex) 삼성 현대 기아회사추상클래스    실제 클래스들의 공통되는 필드, 메소드를 정의한 클래스    공통된 필드와 메소드 이름을 통일할 목적    부모 클래스로만 사용 되며 , 객체 생성 불가    추상 메서드는 자식 클래스에서 오버라이딩! 인터페이스    인터페이스란 .. 개발코드와 객체가 서로 통신 하는 접점이다.    개발 코드는 객체의 내부구조를 몰라도 인터페이스의 메소드만 알고있으면된다.인터페이스 역할    개발 코드가 객체에 종속되지 않게 하여 객체를 교체 할 수 있도록 함.    개발 코드 변경없이 리턴 값 또는 실행 내용이 다양해 질수있다.(다형성)인터페이스 구성멤버    상수, 추상메소드    Java 8 부터는 default 메소드, 정적 메소드상수 필드 선언    인터페이스는 상수 필드만 선언가능    인터페이스에 선언된 모든 필드는 public static final(상수)의 특징을 가짐     상수명은 대문자    선언과 동시에 초기화 (static 블록을 작성할수없으므로}추상 메소드 선언    인터페이스의 메소드는 기본적으로 실행 블록이 없는 추상 메소드로 선언한다.    public abstract를 생략하더라도 컴파일 과정에서 자동적으로 붙음public interface RemoteControl{int MAX_VOLUME = 10;int MIN_VOLUME =0;public abstract void turnOn();void turnOff();\t//public abstract 생략void setVolume(int volume); //public abstract 생략}디폴트 메소드 선언    자바 8 에서 추가된 인터페이스의 새로운 멤버    [public]이 기본타입으로 default를 붙어야 생성된다.public interface RemoteControl{    default void setMute(boolean mute){    if(mute){        System.out.println(\"무음 처리\");    }else{        System.out.println(\"무음 해제\");    }}정적 메소드 선언public interface RemoteControl{    static void emptyBattery(){        System.out.println(\"배터리가 다 소모 되었습니다.\");    }}References.    https://www.hanbit.co.kr/",
        "url": "/java-abstract-interface"
    }
    ,
    
    "beakjoon-2439": {
        "title": "별 찍기 -2",
            "author": "jaehong",
            "category": "",
            "content": "별찍기 2import java.io.*;public class Main {public static void main(String[] args) throws IOException {    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));    int n = Integer.parseInt(br.readLine());    int k = n;    for (int i = 0; i &lt; n; i++) {        for(int j=0; j &lt; n-i-1; j++ ) {          bw.write(\" \");        }         for (int j = 0; j &lt;= i; j++) {          bw.write(\"*\");        }        bw.write(\"\\n\");    }    br.close();    bw.flush();    bw.close();    }}문제출처    백준알고리즘 https://www.acmicpc.net/problem/2439&gt;",
        "url": "/beakjoon-2439"
    }
    ,
    
    "beakjoon-2748": {
        "title": "피보나치 수열2(fibonacci)",
            "author": "jaehong",
            "category": "",
            "content": "피보나치 수열2import java.util.Scanner;public class fibonacci {public static void main(String[] args) {    Scanner sc = new Scanner(System.in);    int num = sc.nextInt();    long[] array = new long[num+1]; //int 범위(2,147,483,647)를 초과 long으로 선언    //고정되어있는 값대입    array[0] = 0;    array[1] = 1;    for(int i=2; i&lt; array.length; i++) {        array[i] = array[i-1] + array[i-2];    }    System.out.println(array[num]);    }}문제출처    백준알고리즘 https://www.acmicpc.net/problem/2748&gt;",
        "url": "/beakjoon-2748"
    }
    ,
    
    "jsp-servlet-3-html": {
        "title": "Servelt 3",
            "author": "jaehong",
            "category": "",
            "content": "Servlet 초기화 파라미터 : ServletConfig특정 Servlet 생성될 때 초기에 필요한 데이터들이 있다. ex)특정 경로 및 아이디 등..    이러한 데이터들을 초기화 파라미터라고 함1. web.xml 사용해서 초기화2. Servlet 파일 사용해서 초기화해당 Servlet에 @WebInitParam 사용해서 초기화ServletContext 모든 서블릿에  데이터를 공유 할 시 (web.xml에 기술)웹어플리케이션 생명주기 감시 : ServletContextListner xml 파일을 통해 Lisner 지정하거나 or 리스너클래스에 어노테이션 사용하거나순서References.References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-servlet-3.html"
    }
    ,
    
    "jsp-servlet-2-html": {
        "title": "Servelt 2",
            "author": "jaehong",
            "category": "",
            "content": "Servlet 작동순서클라이언트에서 servlet 요청이 들어오면 서버는     servlet 컨테이너를 만들고, 요청이 있을때 마다 스레드가 생성Servlet 라이프 사이클(생명주기)    한번생성된 객체는 재사용 -&gt; 요청이 필요할때마다 객체를 생성하는게 아니라서 속도빠름@PostConstruct 선처리: 객체생성과 init()호출사이의 단계에서 메소드 실행@PreDestroy 후처리: destroy() 호출 후에 메소드 실행HTML form 태그Form 태그의 submit 버튼을 클릭하여 데이터를 서버로 전송하면, 해당파일(Servlet)에서는 HttpRequest 객체를 이용하여 Parameter 값을 얻을 수 있다.form 태그에서 Servlet 까지 흐름도한글처리 방식References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-servlet-2.html"
    }
    ,
    
    "jsp-servlet-1-html": {
        "title": "Servelt 1",
            "author": "jaehong",
            "category": "",
            "content": "JSP는 무엇이고, Servlet 은 무엇인가?&lt;Servlet    Tomcat 위에서 동작하는 java Program .. 더 자세히는 Servlet이 초기화 되는 과정을 보면    Java 코드 안에 HTML 코드 (하나의 클래스) .. JSP는 반대JSP , Servlet 차이Servlet    Java 코드 안에 HTML 코드 (하나의 클래스)    data processing(Controller)에 좋다.    Servlet이 수정된 경우 Java 코드를 컴파일(.class 파일 생성)한 후 동적인 페이지를 처리하기 때문에 전체 코드를 업데이트하고 다시 컴파일한 후 재배포하는 작업이 필요하다. (개발 생산성 저하)JSP    Java 언어를 기반으로 하는 Server Side 스크립트 언어    HTML 코드 안에 Java 코드    Servlet를 보완하고 기술을 확장한 스크립트 방식 표준        Servlet의 모든 기능 + 추가적인 기능Servlet 클래스는 HttpServlet 클래스를 상속받음public class HelloWorld extends HttpServlet{}요청처리 및 응답처리객체를 톰캣에서 받음protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {//request 요청처리객체, response 응답처리 객체response.setContentType(\"text/html\"); //응답 처리시 html로PrintWriter writer = response.getWriter();GET방식 &amp; POST방식클라이언트에서 WAS로 요청(request)하는 2가지 방법html 태그안에 method = GET or POST 정함1.GET 방식    서블릿에서 doGet 메소드 호출    서버에는 최대 240Byte까지 데이터를 전달할 수 있다.    URL값이 노출되어 보안취약2.POST 방식    서블릿에서 doPost 메소드 호출    서버에 전달할 수 있는 데이터 크기에 제한이 없다.    URL에는 매개변수가 표시되지않는다. 깨달은것 response.setContentType(\"text/html\"); 이부분을 잘못입력하면response.setContentType(\"html/text\"); 이렇게입력시 실행시키면 웹페이지가 안뜨고 파일을 다운로드 받을 수도있다.Context PathWAS에서 웹어플리케이션을 구분하기 위한 path   이클립스에서 프로젝트생성시  자동으로 server.xml에 추가 References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-servlet-1.html"
    }
    ,
    
    "jsp-introduce-html": {
        "title": "jsp 입문",
            "author": "jaehong",
            "category": "",
            "content": "JSP    프로토콜 : 네트워크상에서 약속한 통신 규약     (Http:웹 통신규약, FTP: 서버에 파일 올리거나 받을때 , SMTP,POP: 메일 DHCP: 가정에서 사용하는 동적 사설 인터넷)    IP: 네트워크 상에서 컴퓨터를 식별할수있는 주소     DNS: IP주소를 인간이 쉽게 외우도록 맵핑한 문자열     Port: 해당 컴퓨터의 구동되고있는 프로그램을 구분할 수 있는 번호 (default로 80)Java 웹    JSP(java Server Page): HTML 파일 내에 JAVA언어를 삽입한 문서    Servlet(Server Applet) JAVA언어로 이루어진 웹프로그래밍 문서    컴포넌트: JSP, Servlet, HTML 등의 웹 어플리케이션을 구현하기 위한 구성요소Jsp 아키텍쳐Servlet 특징    동적 웹어플리케이션 컴포넌트    .java 확장자    java thread 이용하여 동작    MVC패턴에서 Controller맵핑 방법왜 맵핑을하는가?(Why) :너무 길고, 보안에 노출될수 있기에..    기존경로: http://localhost:8090/hello/servelt/com.javalec.ex.Helloworld    URL맵핑시: http://localhost:8090/hello/HWrold    MVC패턴에서 Controller1. web.xml 이용하는방법&lt;servlet&gt;    &lt;servlet-name&gt;helloworld&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.javalec.ex.HelloWorld&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;helloworld&lt;/servlet-name&gt;    &lt;url-pattern&gt;/hw&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;    servlet-name : 임의의 이름을 만듬    servlet-class : 매핑할 클래스 파일명을 패키지명을 포함하여 입력    url-parttern: servlet-class의 매핑할 임의의 이름입력. 반드시 /로시작해야됨!2. java code의 어노테이션 이용@WebServlet(\"/HWorld!!\")// servlet 상단에 선언 web.xml과 어노테이션 동시사용시 web.xml이 적용된다.  References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-introduce.html"
    }
    ,
    
    "java-inheritance": {
        "title": "상속",
            "author": "jaehong",
            "category": "",
            "content": "            자식(하위) 클래스가 부모(상위) 클래스의 멤버를 물려받는 것        상속 대상 : 부모의 필드 &amp; 메소드        개발 시간 단축, 객체의 다형성 구현, 코드의 중복성 다운, 유지보수 등 이점!!    상속 대상의 제한    부모클래스의 private 접근 제한을 가지는 필드와 메소드는 제외    부모클래스가 다른 패키지에 있을때 default 접근 제한을 가지는 필드와 메소드는 제외extends 키워드    부모클래스를 상속받기위한 키워드    자바는 다중상속을 허락하지 않아 한클래스에 하나만 상속가능자식 객체를 생성하면 부모 객체도 생성될까?정답은 생성된다!!    자식 객체 생성시 부모 객체부터 생성되고 자식 객체가 생성된다.    부모 생성자가 호출이 완료되고 자식 생성자가 나중에 호출 완료된다.    자식 생성자가 부모생성자를 호출 하지 않아도 컴파일러가 자동적으로 super()를 통해 부모의 기본생성자를 호출 부모 생성자 호출 super()    super(매개값)은 매개값과 동일한 타입, 개수, 순서가 맞는 부모 생성자 호출    부모 클래스에 기본생성자가 없다면 필수적으로 부모클래스에 맞는(매개변수) 생성자를 작성해야된다.    반드시 자식생성자 첫 줄에 위치 해야된다.    자식 생성자를 호출해서 자식객체를 생성시 부모 객체의 생성자 부터 호출한다.!!public Student(String name, String ssn, int studentNo) {this.studentNo =studentNo;super(\"jaehong\",\"93-12-23\"); //컴파일오류.. 이유: 생성자의 첫줄에서 선언해주어야함!}Override 매소드 재정의    부모 클래스의 메소드를 자식 클래스에서 재정의 하는 것을 말한다.    접근 제한을 더 강하게 오버로딩 할 수 없다. ex) public -&gt; private, default (X) 반대로는 가능@Override 어노테이션     컴파일러에게 부모 클래스의 메소드와 선언부와 동일한지 검사하도록 지시    접근 제한을 더 강하게 오버로딩 할 수 없다. ex) public -&gt; private, default (X) 반대로는 가능    super.부모메소드() : 부모메소드 호출방법다형성(Ployorphism)    같은 타입이지만 실행결과가 다양한 객체를 대입할수있는 성질을 말한다.    A a = new B() //b는 부모객체 A클래스를 상속 받고있는 상태    자식 타입은 부모타입으로 자동 타입 변환된다.    객체를 부품화시킨다.! (타이어 예시 생각!)    부모 클래스 변수 = 자식클래스타입 부모 클래스 변수는 자식과 같은 주소를 가진다.자동 타입 변환 이후 효과    부모 클래스에 선언된 필드와 메소드만 접근 가능    자식 클래스의 재정이된 메소드가 호출된다. (다형성관련)class Parent{    void method1(){};    void method2(){}; // 1번 !!!!!!!!!}////////////////////class Child extends Parent{    void method2(){..}//Overrideing // 2번 !!!!!!!!!    void method3(){}}class ChildEx{    public static void main(String args[]){        Child child = new Child();        Parent parent = child; //Parent로 자동 타입 변환        parent.method1();        parent.method2(); // 부모타입으로 형변환이 됬지만 1번이 아닌 오버라이딩된 2번이 실행된다!! 중요        parent.method3(); // 호출불가능    }}자식 타입인지 확인후 강제 타입instanceofpublic void method(Parent parent) {    if (parent instanceof Child) { //매개변수로 들어오는 객체가 Child 인지확인        Child Child = (Child) parent;    }}References.    https://www.hanbit.co.kr/",
        "url": "/java-inheritance"
    }
    ,
    
    "java-no-parameter-number": {
        "title": "메소드에서 매개변수의 수를 모르는 경우",
            "author": "jaehong",
            "category": "",
            "content": "메소드에서 매개변수의 수를 모르는 경우    메소드에서 여러개의 매개변수를 넘기는 경우 배열을 이용    매개변수의 수가 몇개가 들어올지 모를때에 '...'을 사용함으로 넘겨받는 값의 수에 따라 자동으로 배열 생성public class Parameter {    public static void main(String args[]) {        Cal cal = new Cal();        int[] data = new int[] {1,2,3};        System.out.println(\"sum1 : \" + cal.sum1(data));        System.out.println(\"sum2 : \" + cal.sum2(1,2,3));        System.out.println(\"sum2 : \" + cal.sum2(1,2,3,4,5));    }}class Cal{    int sum1(int[] n) {    int sum=0;        for(int i :n) {        sum += i;        }    return sum;    }    int sum2(int ... n) { //매개변수의 개수를 모를때    int sum=0;    for(int i : n) {    sum += i;    }    return sum;    }}",
        "url": "/java-no-parameter-number"
    }
    ,
    
    "java-annotation": {
        "title": "어노테이션 (Annotation)",
            "author": "jaehong",
            "category": "",
            "content": "프로그램에게 추가적인 정보를 제공해주는 메타데이터(metadata)이다.    컴파일러에게 코드 작성 문법에러 체크하도록 정보제공                                    ex) Override                            개발 툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보 제공                                    ex) XML 설정 파일을 자동 생성한다거나 배포를 위한 JAR 압축 파일을 자동생성가능                            실행시(런타임시) 특정 기능을 실행하도록 정보 제공                                    ex) Servlet 이나 Controller 객체 사용시                        기본 엘리먼트 valuepublic @interface AnnotationName{String value;int elementName() default 5;}어노테이션을 적용할때 엘리먼트명을 생략가능        @AnnotationName(\"값입니다\") //value에 \"값입니다\" 저장두개 이상의 속성을 기술할때는 value=값 형태로 기술    @AnnotationName(value=\"값입니다\", elementName = 4);어노테이션 적용대상    java.lang.annotationElementType 열거 상수로 정의어노테이션 적용 대상 방법    @Target 어노테이션으로 적용대상지정//예시@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})public @interface AnnotationName{}어노테이션 유지정책    어노테이션 적용 코드가 언제까지 유지될것인가를 기술한것    java.lang.annotation.RetentionPolicy 열거 상수로 정의되어 있음                RetenionPolicy 열거 상수        설명                        SOURCE        바이트코드에서는 어노테이션이 유지되지 않는 정책, 개발자가 소스에서어떤 정보를 얻을 목적으로 유지하는 정책                CLASS        컴파일러가 바이트 코드를 만들때 까지는 유지그러나 어노테이션의 값을 클래스 실행시 얻을 수 없다.클래스상에서만 존재하고 실제 실행시 정보를 읽지 못하는 정책                RUNTIME        바이트 코드 까지 유지가 되고 바이트 코드파일을 로딩을 시키고 나서 실제프로그래밍 실행시 어노테이션의 정보를 읽고 이용을 할 수 있도록 하는 유지정책 대부분사용        리플렉션(reflection): 런타임에 클래스의 메타 정보를 얻는 기능    클래스가 가진 필드, 생성자, 메소드, 어노테이션 정보을 얻을 수 있다.    Runtime(실행중에) 어노테이션 정보를 얻으려면 유지 정책을 RUNTIME으로 설정해야됨유지 정책 지정방법    @Retention 어노테이션으로 유지정책을 지정    @Retention의 기본 엘리먼트인 value의 타입은 RetentionPolicy@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)public @interface AnnotationName{}References.    https://www.hanbit.co.kr/",
        "url": "/java-annotation"
    }
    ,
    
    "java-getter-setter": {
        "title": "Getter와 Setter",
            "author": "jaehong",
            "category": "",
            "content": "     Getter            일반적으로 클래스선언시 필드는 prvite 접근제한을 한다.   (외부로 부터 변경을 막기위해)        때에 따라서 필드를 읽기만 하기 위해 Getter를 사용한다.        Getter는 private 필드를의 값을 리턴 하는 구현기술 중 하나이다.        getFieldName() 또는 isFieldName() 메소드의 이름을 가진다.        Field 타입이 boolean 일경우 isFieldName()로 나머지는 getFieldName()이 된다.              Setter            외부에서 필드의 값을 수정할 때에 올바른 값만 필드에 저장할 수 있도록 도와준다.        필요할경우 유효성검사 가능        setFiledName(타입변수)             CODE     123456789101112131415161718private&nbsp;int&nbsp;num;&nbsp;public&nbsp;int&nbsp;getNum()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;num;}public&nbsp;void&nbsp;setNum(int&nbsp;num){&nbsp;&nbsp;&nbsp;&nbsp;this.num&nbsp;=&nbsp;num;}//---------------------------------private&nbsp;Boolean&nbsp;success;&nbsp;public&nbsp;Boolean&nbsp;isSuccess(){&nbsp;&nbsp;&nbsp;&nbsp;//boolean&nbsp;일때는&nbsp;is&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;success;}&nbsp;public&nbsp;void&nbsp;setSuceess(Boolean&nbsp;success){&nbsp;&nbsp;&nbsp;&nbsp;this.success&nbsp;=&nbsp;success;}&nbsp;Colored by Color ScriptercsReferences.    https://www.hanbit.co.kr/",
        "url": "/java-getter-setter"
    }
    ,
    
    "java-access-modifier": {
        "title": "접근 제한자(Access Modifier)",
            "author": "jaehong",
            "category": "",
            "content": "    클래스       제한    생성자       제한    필드와 메소드 제한publicprotected            같은패키지:default와 동일        다른패키지:자식클래스만 접근 허용상속의 개념과 연관        클래스 앞에는 선언할수없다. 필드 메서드 생성자는 가능    defaultprivateReferences.    https://www.hanbit.co.kr/",
        "url": "/java-access-modifier"
    }
    ,
    
    "java-pakage": {
        "title": "패키지(Pakage)",
            "author": "jaehong",
            "category": "",
            "content": "    상위 패키지와 하위 패키지는 도트(.)로 구분    패키지이름은 소문자 &amp;&amp; 숫자,특수문자 안됨 &amp;&amp; 도메인 역순(com.naver.projectname) 명령 라인 환경에서(CLI) 컴파일&lt;ul&gt;    &lt;li&gt;javac XXX.java &lt;-- 이 명령어로 컴파일시 .class는 생기나 패키지는 자동으로 생성안됨&lt;/li&gt;    &lt;li&gt;javac -d [패키지가 생성될위치] xxx.java &lt;-- -d 옵션으로 패키지 생성될 위치 &lt;/li&gt;    &lt;li&gt;클래스파일 실행 명령어 -&gt; ex) C:\\eclispe-workspace\\Test\\bin&gt; java com.test.Calculator  &lt;/li&gt;&lt;/ul&gt;References.    https://www.hanbit.co.kr/",
        "url": "/java-pakage"
    }
    ,
    
    "java-final": {
        "title": "final (field,Static final(상수),&lt;br&gt; Class, Method)",
            "author": "jaehong",
            "category": "",
            "content": "            한번의 초기화로 인하여 값을 변경할수 없는 필드        메서드를 호출해서 객체가 사용할수있도록 준비하는 역할 수행         CODE public class Person {    final String nation = \"kr\"; //값을 초기에 할당하거나    final String ssn;    public Person(String ssn) {//생성자 선언시 할당하거나    this.ssn = ssn;              //final은 최초한번만 값대입가능    }} 상수 (Static final)              final 필드가 객체 마다 가지는 인스턴스 필드라고 하면         상수는 객체마다 가지고있지 않고 메소드 영역에서 클래스별로 관리되는 정적 필드        공용데이터로 관리         CODE     static final dobule EARTH_RADIUS = 6400;    //상수의 이름은 전부 대문자로 작성 단어와 연결시 _(언더바)    static final double EARTH_SURFACE_AREA;    static{    EARTH_SURFACE_AREA = 4 * Math.PI *  EARTH_RADIUS *  EARTH_RADIUS;}final 클래스    상속과 연관    부모로 사용할 수 없는 클래스     CODE     public final class A{} //A라는 final 클래스가 있을때    ///////////////////////////////////////////////    public class B extends A{} // A클래스가 final 클래스로 선언되어있어 상속을 받지못함 컴파일에러 발생final 메소드    상속과 연관    자식이 재정의할 수 없는 메소드     CODE public class Car{    public int speed;    public  void speedUp(){        speed += 1;    }    public final void stop(){   //메소드도 final 클래스와 마찬가지로 final 메소드인 stop을 override하려고하면 컴파일 에러발생!        System.out.println(\"차를 멈춤\");        speed =0;    }}References.    https://www.hanbit.co.kr/",
        "url": "/java-final"
    }
    ,
    
    "dp-singletonpattern": {
        "title": "싱글톤 패턴(Singleton-Pattern)",
            "author": "jaehong",
            "category": "",
            "content": "디자인 패턴(Design Pattern List)            싱글톤 패턴 (Singleton pattern)         싱글턴(Singleton) 이란 ?                     싱글턴 패턴은 인스턴스가 오직 1개만 생성되야 하는 경우에 사용되는 패턴입니다.             예를들어 레지스트리 같은 설정 파일의 경우 객체가 여러개 생성되면 설정 값이 변경될 위험이 생길 수 있습니다.                 인스턴스가 1개만 생성되는 특징을 가진 싱글턴 패턴을 이용하면, 하나의 인스턴스를 메모리에 등록해서 여러 스레드가 동시에 해당 인스턴스를 공유하여 사용하게끔 할 수 있으므로, 요청이 많은 곳에서 사용하면 효율을 높일 수 있습니다.    주의 해야할 점은 싱글턴을 만들때 동시성(Concurrency) 문제를 고려해서 싱글턴을 설계해야합니다.References.    https://medium.com/webeveloper",
        "url": "/dp-singletonPattern"
    }
    ,
    
    "dp-design-pattern": {
        "title": "디자인 패턴 리스트(Design-Pattern-List)",
            "author": "jaehong",
            "category": "",
            "content": "디자인 패턴(Design Pattern List)            싱글톤 패턴 (Singleton pattern)    ",
        "url": "/dp-design-pattern"
    }
    ,
    
    "java-constructor": {
        "title": "생성자(Constructor)",
            "author": "jaehong",
            "category": "",
            "content": "     new 클래스();                    필드의 값을 설정하거나            메서드를 호출해서 객체가 사용할수있도록 준비하는 역할 수행                 생성자(Constractor)References.    https://www.hanbit.co.kr/",
        "url": "/java-constructor"
    }
    ,
    
    "jekyll-basic": {
        "title": "처음만든날",
            "author": "jaehong",
            "category": "",
            "content": "블로그처음만든날",
        "url": "/jekyll-basic"
    }
    ,
    
    "java-basic": {
        "title": "java 강좌(1) - java 기본",
            "author": "jaehong",
            "category": "",
            "content": "이글은 java에 관한 내용이 있습니다.11",
        "url": "/java-basic"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://JaeHong2.github.io//">오늘의 공부기록</a> &copy; 2021</section>
                <section class="poweredby">

                    <a href="https://github.com/jaehong2" target="_blank" rel="noopener">GitHub</a>
                </section>
                <nav class="site-footer-nav">
                    <a></a>
                    <a>본 홈페이지는 개인공부 페이지입니다.</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">Search</h1>
            <p class="subscribe-overlay-description">
                검색 </p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()"
               id="searchtext" type="text" name="searchtext"
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>

    <!-- 2020년 404 에러나서 12-25일 주석처리함-->
    <!--<script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script> -->


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
